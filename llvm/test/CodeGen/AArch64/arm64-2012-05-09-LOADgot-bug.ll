; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=arm64-apple-ios < %s | FileCheck %s
; RUN: llc -mtriple=arm64-linux-gnu -relocation-model=pic < %s | FileCheck %s --check-prefix=CHECK-LINUX
; <rdar://problem/11392109>

define hidden void @t(i64* %addr) optsize ssp {
; CHECK-LABEL: t:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh0:
; CHECK-NEXT:    adrp x8, _x@GOTPAGE
; CHECK-NEXT:  Lloh1:
; CHECK-NEXT:    ldr x8, [x8, _x@GOTPAGEOFF]
; CHECK-NEXT:    mov w8, w8
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGot Lloh0, Lloh1
;
; CHECK-LINUX-LABEL: t:
; CHECK-LINUX:       // %bb.0: // %entry
; CHECK-LINUX-NEXT:    adrp x8, :got:x
; CHECK-LINUX-NEXT:    ldr x8, [x8, :got_lo12:x]
; CHECK-LINUX-NEXT:    mov w8, w8
; CHECK-LINUX-NEXT:    str x8, [x0]
; CHECK-LINUX-NEXT:    ret
entry:
  store i64 zext (i32 ptrtoint (i64 (i32)* @x to i32) to i64), i64* %addr, align 8
  ret void
}

declare i64 @x(i32) optsize

; Worth checking the Linux code is sensible too: only way to access
; the GOT is via a 64-bit load. Just loading wN is unacceptable
; (there's no ELF relocation to do that).

; CHECK-LINUX: adrp {{x[0-9]+}}, :got:x
; CHECK-LINUX: ldr {{x[0-9]+}}, [{{x[0-9]+}}, :got_lo12:x]
