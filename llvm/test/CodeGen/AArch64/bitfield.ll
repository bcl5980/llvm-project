; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs < %s -mtriple=aarch64-none-linux-gnu | FileCheck %s

@var32 = dso_local global i32 0
@var64 = dso_local global i64 0

define dso_local void @test_extendb32(i8 %var) {
; CHECK-LABEL: test_extendb32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, var32
; CHECK-NEXT:    sxtb w9, w0
; CHECK-NEXT:    and w10, w0, #0xff
; CHECK-NEXT:    str w9, [x8, :lo12:var32]
; CHECK-NEXT:    str w10, [x8, :lo12:var32]
; CHECK-NEXT:    ret

  %sxt32 = sext i8 %var to i32
  store volatile i32 %sxt32, i32* @var32

; N.b. this doesn't actually produce a bitfield instruction at the
; moment, but it's still a good test to have and the semantics are
; correct.
  %uxt32 = zext i8 %var to i32
  store volatile i32 %uxt32, i32* @var32
  ret void
}

define dso_local void @test_extendb64(i8 %var) {
; CHECK-LABEL: test_extendb64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    adrp x8, var64
; CHECK-NEXT:    sxtb x9, w0
; CHECK-NEXT:    and w10, w0, #0xff
; CHECK-NEXT:    str x9, [x8, :lo12:var64]
; CHECK-NEXT:    str x10, [x8, :lo12:var64]
; CHECK-NEXT:    ret

  %sxt64 = sext i8 %var to i64
  store volatile i64 %sxt64, i64* @var64

; N.b. this doesn't actually produce a bitfield instruction at the
; moment, but it's still a good test to have and the semantics are
; correct.
  %uxt64 = zext i8 %var to i64
  store volatile i64 %uxt64, i64* @var64
  ret void
}

define dso_local void @test_extendh32(i16 %var) {
; CHECK-LABEL: test_extendh32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, var32
; CHECK-NEXT:    sxth w9, w0
; CHECK-NEXT:    and w10, w0, #0xffff
; CHECK-NEXT:    str w9, [x8, :lo12:var32]
; CHECK-NEXT:    str w10, [x8, :lo12:var32]
; CHECK-NEXT:    ret

  %sxt32 = sext i16 %var to i32
  store volatile i32 %sxt32, i32* @var32

; N.b. this doesn't actually produce a bitfield instruction at the
; moment, but it's still a good test to have and the semantics are
; correct.
  %uxt32 = zext i16 %var to i32
  store volatile i32 %uxt32, i32* @var32
  ret void
}

define dso_local void @test_extendh64(i16 %var) {
; CHECK-LABEL: test_extendh64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    adrp x8, var64
; CHECK-NEXT:    sxth x9, w0
; CHECK-NEXT:    and w10, w0, #0xffff
; CHECK-NEXT:    str x9, [x8, :lo12:var64]
; CHECK-NEXT:    str x10, [x8, :lo12:var64]
; CHECK-NEXT:    ret

  %sxt64 = sext i16 %var to i64
  store volatile i64 %sxt64, i64* @var64

; N.b. this doesn't actually produce a bitfield instruction at the
; moment, but it's still a good test to have and the semantics are
; correct.
  %uxt64 = zext i16 %var to i64
  store volatile i64 %uxt64, i64* @var64
  ret void
}

define dso_local void @test_extendw(i32 %var) {
; CHECK-LABEL: test_extendw:
; CHECK:       // %bb.0:
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    adrp x8, var64
; CHECK-NEXT:    sxtw x9, w0
; CHECK-NEXT:    mov w10, w0
; CHECK-NEXT:    str x9, [x8, :lo12:var64]
; CHECK-NEXT:    str x10, [x8, :lo12:var64]
; CHECK-NEXT:    ret

  %sxt64 = sext i32 %var to i64
  store volatile i64 %sxt64, i64* @var64

  %uxt64 = zext i32 %var to i64
  store volatile i64 %uxt64, i64* @var64
  ret void
}

define dso_local void @test_shifts(i32 %val32, i64 %val64) {
; CHECK-LABEL: test_shifts:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, var32
; CHECK-NEXT:    asr w9, w0, #31
; CHECK-NEXT:    lsr w10, w0, #8
; CHECK-NEXT:    adrp x11, var64
; CHECK-NEXT:    lsl w12, w0, #1
; CHECK-NEXT:    str w9, [x8, :lo12:var32]
; CHECK-NEXT:    asr x9, x1, #31
; CHECK-NEXT:    str w10, [x8, :lo12:var32]
; CHECK-NEXT:    lsr x10, x1, #8
; CHECK-NEXT:    str w12, [x8, :lo12:var32]
; CHECK-NEXT:    lsl x12, x1, #63
; CHECK-NEXT:    str x9, [x11, :lo12:var64]
; CHECK-NEXT:    asr x9, x1, #63
; CHECK-NEXT:    str x10, [x11, :lo12:var64]
; CHECK-NEXT:    lsr x10, x1, #63
; CHECK-NEXT:    str x12, [x11, :lo12:var64]
; CHECK-NEXT:    lsr w12, w0, #31
; CHECK-NEXT:    str x9, [x11, :lo12:var64]
; CHECK-NEXT:    lsl w9, w0, #31
; CHECK-NEXT:    str x10, [x11, :lo12:var64]
; CHECK-NEXT:    str w12, [x8, :lo12:var32]
; CHECK-NEXT:    str w9, [x8, :lo12:var32]
; CHECK-NEXT:    ret

  %shift1 = ashr i32 %val32, 31
  store volatile i32 %shift1, i32* @var32

  %shift2 = lshr i32 %val32, 8
  store volatile i32 %shift2, i32* @var32

  %shift3 = shl i32 %val32, 1
  store volatile i32 %shift3, i32* @var32

  %shift4 = ashr i64 %val64, 31
  store volatile i64 %shift4, i64* @var64

  %shift5 = lshr i64 %val64, 8
  store volatile i64 %shift5, i64* @var64

  %shift6 = shl i64 %val64, 63
  store volatile i64 %shift6, i64* @var64

  %shift7 = ashr i64 %val64, 63
  store volatile i64 %shift7, i64* @var64

  %shift8 = lshr i64 %val64, 63
  store volatile i64 %shift8, i64* @var64

  %shift9 = lshr i32 %val32, 31
  store volatile i32 %shift9, i32* @var32

  %shift10 = shl i32 %val32, 31
  store volatile i32 %shift10, i32* @var32

  ret void
}

; LLVM can produce in-register extensions taking place entirely with
; 64-bit registers too.
define dso_local void @test_sext_inreg_64(i64 %in) {
; CHECK-LABEL: test_sext_inreg_64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, var64
; CHECK-NEXT:    sbfx x9, x0, #0, #1
; CHECK-NEXT:    sxtb x10, w0
; CHECK-NEXT:    sxth x11, w0
; CHECK-NEXT:    sxtw x12, w0
; CHECK-NEXT:    str x9, [x8, :lo12:var64]
; CHECK-NEXT:    str x10, [x8, :lo12:var64]
; CHECK-NEXT:    str x11, [x8, :lo12:var64]
; CHECK-NEXT:    str x12, [x8, :lo12:var64]
; CHECK-NEXT:    ret

; i1 doesn't have an official alias, but crops up and is handled by
; the bitfield ops.
  %trunc_i1 = trunc i64 %in to i1
  %sext_i1 = sext i1 %trunc_i1 to i64
  store volatile i64 %sext_i1, i64* @var64

  %trunc_i8 = trunc i64 %in to i8
  %sext_i8 = sext i8 %trunc_i8 to i64
  store volatile i64 %sext_i8, i64* @var64

  %trunc_i16 = trunc i64 %in to i16
  %sext_i16 = sext i16 %trunc_i16 to i64
  store volatile i64 %sext_i16, i64* @var64

  %trunc_i32 = trunc i64 %in to i32
  %sext_i32 = sext i32 %trunc_i32 to i64
  store volatile i64 %sext_i32, i64* @var64
  ret void
}

; These instructions don't actually select to official bitfield
; operations, but it's important that we select them somehow:
define dso_local void @test_zext_inreg_64(i64 %in) {
; CHECK-LABEL: test_zext_inreg_64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, var64
; CHECK-NEXT:    and w9, w0, #0xff
; CHECK-NEXT:    and w10, w0, #0xffff
; CHECK-NEXT:    mov w11, w0
; CHECK-NEXT:    str x9, [x8, :lo12:var64]
; CHECK-NEXT:    str x10, [x8, :lo12:var64]
; CHECK-NEXT:    str x11, [x8, :lo12:var64]
; CHECK-NEXT:    ret

  %trunc_i8 = trunc i64 %in to i8
  %zext_i8 = zext i8 %trunc_i8 to i64
  store volatile i64 %zext_i8, i64* @var64

  %trunc_i16 = trunc i64 %in to i16
  %zext_i16 = zext i16 %trunc_i16 to i64
  store volatile i64 %zext_i16, i64* @var64

  %trunc_i32 = trunc i64 %in to i32
  %zext_i32 = zext i32 %trunc_i32 to i64
  store volatile i64 %zext_i32, i64* @var64

  ret void
}

define dso_local i64 @test_sext_inreg_from_32(i32 %in) {
; CHECK-LABEL: test_sext_inreg_from_32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    sbfx x0, x0, #0, #1
; CHECK-NEXT:    ret

  %small = trunc i32 %in to i1
  %ext = sext i1 %small to i64

  ; Different registers are of course, possible, though suboptimal. This is
  ; making sure that a 64-bit "(sext_inreg (anyext GPR32), i1)" uses the 64-bit
  ; sbfx rather than just 32-bits.
  ret i64 %ext
}


define dso_local i32 @test_ubfx32(i32* %addr) {
; CHECK-LABEL: test_ubfx32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr w8, [x0]
; CHECK-NEXT:    ubfx w0, w8, #23, #3
; CHECK-NEXT:    ret

   %fields = load i32, i32* %addr
   %shifted = lshr i32 %fields, 23
   %masked = and i32 %shifted, 7
   ret i32 %masked
}

define dso_local i64 @test_ubfx64(i64* %addr) {
; CHECK-LABEL: test_ubfx64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr x8, [x0]
; CHECK-NEXT:    ubfx x8, x8, #25, #10
; CHECK-NEXT:    mov w0, w8
; CHECK-NEXT:    ret
   %fields = load i64, i64* %addr
   %shifted = lshr i64 %fields, 25
   %masked = and i64 %shifted, 1023
   ret i64 %masked
}

define dso_local i32 @test_sbfx32(i32* %addr) {
; CHECK-LABEL: test_sbfx32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr w8, [x0]
; CHECK-NEXT:    sbfx w0, w8, #6, #3
; CHECK-NEXT:    ret

   %fields = load i32, i32* %addr
   %shifted = shl i32 %fields, 23
   %extended = ashr i32 %shifted, 29
   ret i32 %extended
}

define dso_local i64 @test_sbfx64(i64* %addr) {
; CHECK-LABEL: test_sbfx64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr x8, [x0]
; CHECK-NEXT:    sbfx x0, x8, #0, #63
; CHECK-NEXT:    ret

   %fields = load i64, i64* %addr
   %shifted = shl i64 %fields, 1
   %extended = ashr i64 %shifted, 1
   ret i64 %extended
}

define i32 @test_ubfx_mask(i32 %lhs, i32 %rhs) {
; CHECK-LABEL: test_ubfx_mask:
; CHECK:       // %bb.0:
; CHECK-NEXT:    lsr w0, w1, #20
; CHECK-NEXT:    ret
  %mask = and i32 %lhs, 20
  %i7 = add i32 %mask, 1
  %i8 = xor i32 %lhs, 20
  %i9 = xor i32 %i8, %i7
  %i10 = and i32 %i9, 20
  %shift = lshr i32 %rhs, %i10
  %shift.masked = and i32 %shift, 65535
  ret i32 %shift.masked
}
