; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=arm64ec-pc-windows-msvc < %s | FileCheck %s

%struct.s3 = type { [3 x i8], [61 x i8] }
%struct.s4 = type { [4 x i8], [28 x i8] }
%struct.s12 = type { [12 x i8], [52 x i8] }
%struct.s16 = type { [16 x i8], [16 x i8] }
%struct.s17 = type { [17 x i8], [47 x i8] }
%struct.s33 = type { [33 x i8], [3 x i8] }
%struct.s65 = type { [65 x i8], i8 }
%struct.s129 = type { [129 x i8], [15 x i8] }
%struct.s257 = type { [257 x i8], [31 x i8] }
%struct.f2 = type { [2 x float] }
%struct.f3 = type { [3 x float], [52 x i8] }
%struct.f4 = type { [4 x float], [16 x i8] }
%struct.f5 = type { [5 x float], [12 x i8] }
%struct.d2 = type { [2 x double], [48 x i8] }
%struct.d3 = type { [3 x double], [40 x i8] }
%struct.d4 = type { [4 x double] }
%struct.d5 = type { [5 x double], [8 x i8] }

@pfnstruct1 = global ptr null, align 8
@pfnstruct2 = global ptr null, align 8
@pfnstruct3 = global ptr null, align 8
@pfnstruct4 = global ptr null, align 8
@pfnstruct5 = global ptr null, align 8
@pfnstruct6 = global ptr null, align 8
@pfnstruct7 = global ptr null, align 8
@pfnstruct8 = global ptr null, align 8
@pfnstruct9 = global ptr null, align 8
@pfnstruct10 = global ptr null, align 8
@pfnstruct11 = global ptr null, align 8
@pfnstruct12 = global ptr null, align 8
@pfnstruct13 = global ptr null, align 8
@pfnstruct14 = global ptr null, align 8
@pfnstruct15 = global ptr null, align 8
@pfnstruct16 = global ptr null, align 8
@pfnstruct17 = global ptr null, align 8
@pfnstruct33 = global ptr null, align 8
@pfnstruct65 = global ptr null, align 8
@pfnstruct129 = global ptr null, align 8
@pfnstruct257 = global ptr null, align 8
@pfnstructf2 = global ptr null, align 8
@pfnstructf3 = global ptr null, align 8
@pfnstructf4 = global ptr null, align 8
@pfnstructf5 = global ptr null, align 8
@pfnstructd2 = global ptr null, align 8
@pfnstructd3 = global ptr null, align 8
@pfnstructd4 = global ptr null, align 8
@pfnstructd5 = global ptr null, align 8


define dso_local arm64ec_argsize(1) i8 @callstruct1(i64 arm64ec_argsize(1) %x.coerce) {
; CHECK-LABEL: callstruct1:
; CHECK:       .seh_proc callstruct1
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct1
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m1$m1)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m1$m1)
; CHECK-NEXT:    and x0, x0, #0xff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct1]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct1, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 255
  %call = tail call arm64ec_argsize(1) i8 %0(i64 arm64ec_argsize(1) %coerce.dive1.coerce.0.insert.ext)
  ret i8 %call
}


declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1 immarg)


define dso_local arm64ec_argsize(8) i64 @callstruct2(i64 arm64ec_argsize(8) %x.coerce) {
; CHECK-LABEL: callstruct2:
; CHECK:       .seh_proc callstruct2
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct2
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct2]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct2, align 8
  %call = tail call arm64ec_argsize(8) i64 %0(i64 arm64ec_argsize(8) %x.coerce)
  ret i64 %call
}


define dso_local arm64ec_argsize(64) void @callstruct3(ptr sret(%struct.s3) align 64 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstruct3:
; CHECK:       .seh_proc callstruct3
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffc0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct3
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct3]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s3, align 64
  %0 = load ptr, ptr @pfnstruct3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.tmp, ptr align 64 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.s3) align 64 %agg.result, ptr arm64ec_argsize(64) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(32) void @callstruct4(ptr sret(%struct.s4) align 32 %agg.result, ptr arm64ec_argsize(32) %x) {
; CHECK-LABEL: callstruct4:
; CHECK:       .seh_proc callstruct4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #48
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct4
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct4]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s4, align 32
  %0 = load ptr, ptr @pfnstruct4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.tmp, ptr align 32 %x, i64 32, i1 false)
  call arm64ec_argsize(32) void %0(ptr sret(%struct.s4) align 32 %agg.result, ptr arm64ec_argsize(32) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(6) i48 @callstruct5(i64 arm64ec_argsize(6) %x.coerce) {
; CHECK-LABEL: callstruct5:
; CHECK:       .seh_proc callstruct5
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct5
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m6$m6)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m6$m6)
; CHECK-NEXT:    and x0, x0, #0xffffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct5]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct5, align 8
  %agg.tmp.coerce.0.insert.ext = and i64 %x.coerce, 281474976710655
  %call = tail call arm64ec_argsize(6) i48 %0(i64 arm64ec_argsize(6) %agg.tmp.coerce.0.insert.ext)
  ret i48 %call
}


define dso_local arm64ec_argsize(8) i64 @callstruct6(i64 arm64ec_argsize(8) %x.coerce) {
; CHECK-LABEL: callstruct6:
; CHECK:       .seh_proc callstruct6
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct6
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct6]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct6, align 8
  %call = tail call arm64ec_argsize(8) i64 %0(i64 arm64ec_argsize(8) %x.coerce)
  ret i64 %call
}


define dso_local arm64ec_argsize(8) i64 @callstruct7(i64 arm64ec_argsize(8) %x.coerce) {
; CHECK-LABEL: callstruct7:
; CHECK:       .seh_proc callstruct7
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct7
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct7]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct7, align 8
  %call = tail call arm64ec_argsize(8) i64 %0(i64 arm64ec_argsize(8) %x.coerce)
  ret i64 %call
}


define dso_local arm64ec_argsize(16) i128 @callstruct8(i128 arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstruct8:
; CHECK:       .seh_proc callstruct8
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct8
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m16a16$m16a16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m16a16$m16a16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct8]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct8, align 8
  %call = tail call arm64ec_argsize(16) i128 %0(i128 arm64ec_argsize(16) %x.coerce)
  ret i128 %call
}


define dso_local arm64ec_argsize(12) [2 x i64] @callstruct9([2 x i64] arm64ec_argsize(12) %x.coerce) {
; CHECK-LABEL: callstruct9:
; CHECK:       .seh_proc callstruct9
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct9
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m12$m12)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m12$m12)
; CHECK-NEXT:    and x1, x1, #0xffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct9]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct9, align 8
  %agg.tmp.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 4294967295
  %.fca.1.insert3 = insertvalue [2 x i64] %x.coerce, i64 %agg.tmp.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(12) [2 x i64] %0([2 x i64] arm64ec_argsize(12) %.fca.1.insert3)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %retval.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 4294967295
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %retval.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(10) [2 x i64] @callstruct10([2 x i64] arm64ec_argsize(10) %x.coerce) {
; CHECK-LABEL: callstruct10:
; CHECK:       .seh_proc callstruct10
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct10
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m10$m10)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m10$m10)
; CHECK-NEXT:    and x1, x1, #0xffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct10]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct10, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 65535
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(10) [2 x i64] %0([2 x i64] arm64ec_argsize(10) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 65535
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(11) [2 x i64] @callstruct11([2 x i64] arm64ec_argsize(11) %x.coerce) {
; CHECK-LABEL: callstruct11:
; CHECK:       .seh_proc callstruct11
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct11
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m11$m11)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m11$m11)
; CHECK-NEXT:    and x1, x1, #0xffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct11]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct11, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 16777215
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(11) [2 x i64] %0([2 x i64] arm64ec_argsize(11) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 16777215
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(64) void @callstruct12(ptr sret(%struct.s12) align 64 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstruct12:
; CHECK:       .seh_proc callstruct12
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffc0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct12
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct12]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s12, align 64
  %0 = load ptr, ptr @pfnstruct12, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.tmp, ptr align 64 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.s12) align 64 %agg.result, ptr arm64ec_argsize(64) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(16) [2 x i64] @callstruct13([2 x i64] arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstruct13:
; CHECK:       .seh_proc callstruct13
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct13
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m16$m16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m16$m16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct13]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct13, align 8
  %call = tail call arm64ec_argsize(16) [2 x i64] %0([2 x i64] arm64ec_argsize(16) %x.coerce)
  ret [2 x i64] %call
}


define dso_local arm64ec_argsize(16) [2 x i64] @callstruct14([2 x i64] arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstruct14:
; CHECK:       .seh_proc callstruct14
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct14
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m16$m16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m16$m16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct14]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct14, align 8
  %call = tail call arm64ec_argsize(16) [2 x i64] %0([2 x i64] arm64ec_argsize(16) %x.coerce)
  ret [2 x i64] %call
}


define dso_local arm64ec_argsize(16) i128 @callstruct15(i128 arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstruct15:
; CHECK:       .seh_proc callstruct15
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct15
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m16a16$m16a16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m16a16$m16a16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct15]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct15, align 8
  %call = tail call arm64ec_argsize(16) i128 %0(i128 arm64ec_argsize(16) %x.coerce)
  ret i128 %call
}


define dso_local arm64ec_argsize(32) void @callstruct16(ptr sret(%struct.s16) align 32 %agg.result, ptr arm64ec_argsize(32) %x) {
; CHECK-LABEL: callstruct16:
; CHECK:       .seh_proc callstruct16
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #48
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct16
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct16]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s16, align 32
  %0 = load ptr, ptr @pfnstruct16, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.tmp, ptr align 32 %x, i64 32, i1 false)
  call arm64ec_argsize(32) void %0(ptr sret(%struct.s16) align 32 %agg.result, ptr arm64ec_argsize(32) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(64) void @callstruct17(ptr sret(%struct.s17) align 64 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstruct17:
; CHECK:       .seh_proc callstruct17
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffc0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct17
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct17]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s17, align 64
  %0 = load ptr, ptr @pfnstruct17, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.tmp, ptr align 64 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.s17) align 64 %agg.result, ptr arm64ec_argsize(64) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(36) void @callstruct33(ptr sret(%struct.s33) align 4 %agg.result, ptr arm64ec_argsize(36) %x) {
; CHECK-LABEL: callstruct33:
; CHECK:       .seh_proc callstruct33
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    str x30, [sp, #48] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct33
; CHECK-NEXT:    ldr w10, [x0, #32]
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    str w10, [sp, #32]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m36$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m36$i8)
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct33]
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #48] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 48
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s33, align 4
  %0 = load ptr, ptr @pfnstruct33, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg.tmp, ptr align 4 %x, i64 36, i1 false)
  call arm64ec_argsize(36) void %0(ptr sret(%struct.s33) align 4 %agg.result, ptr arm64ec_argsize(36) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(66) void @callstruct65(ptr sret(%struct.s65) align 2 %agg.result, ptr arm64ec_argsize(66) %x) {
; CHECK-LABEL: callstruct65:
; CHECK:       .seh_proc callstruct65
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #96
; CHECK-NEXT:    .seh_stackalloc 96
; CHECK-NEXT:    str x30, [sp, #80] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 80
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct65
; CHECK-NEXT:    ldrh w10, [x0, #64]
; CHECK-NEXT:    ldp q0, q1, [x0, #32]
; CHECK-NEXT:    adrp x12, __os_arm64x_check_icall
; CHECK-NEXT:    strh w10, [sp, #64]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m66$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m66$i8)
; CHECK-NEXT:    ldp q3, q2, [x0]
; CHECK-NEXT:    stp q0, q1, [sp, #32]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct65]
; CHECK-NEXT:    stp q3, q2, [sp]
; CHECK-NEXT:    ldr x9, [x12, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #80] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 80
; CHECK-NEXT:    add sp, sp, #96
; CHECK-NEXT:    .seh_stackalloc 96
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s65, align 2
  %0 = load ptr, ptr @pfnstruct65, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 2 %agg.tmp, ptr align 2 %x, i64 66, i1 false)
  call arm64ec_argsize(66) void %0(ptr sret(%struct.s65) align 2 %agg.result, ptr arm64ec_argsize(66) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(144) void @callstruct129(ptr sret(%struct.s129) align 16 %agg.result, ptr arm64ec_argsize(144) %x) {
; CHECK-LABEL: callstruct129:
; CHECK:       .seh_proc callstruct129
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #160
; CHECK-NEXT:    .seh_stackalloc 160
; CHECK-NEXT:    str x30, [sp, #144] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 144
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    ldp q0, q1, [x0, #96]
; CHECK-NEXT:    adrp x9, pfnstruct129
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldr q2, [x0, #128]
; CHECK-NEXT:    stp q0, q1, [sp, #96]
; CHECK-NEXT:    ldp q3, q0, [x0, #16]
; CHECK-NEXT:    str q2, [sp, #128]
; CHECK-NEXT:    ldp q4, q2, [x0, #48]
; CHECK-NEXT:    stp q0, q4, [sp, #32]
; CHECK-NEXT:    ldr q1, [x0, #80]
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct129]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m144a16$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m144a16$i8)
; CHECK-NEXT:    stp q0, q3, [sp]
; CHECK-NEXT:    stp q2, q1, [sp, #64]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #144] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 144
; CHECK-NEXT:    add sp, sp, #160
; CHECK-NEXT:    .seh_stackalloc 160
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s129, align 16
  %0 = load ptr, ptr @pfnstruct129, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %agg.tmp, ptr align 16 %x, i64 144, i1 false)
  call arm64ec_argsize(144) void %0(ptr sret(%struct.s129) align 16 %agg.result, ptr arm64ec_argsize(144) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(288) void @callstruct257(ptr sret(%struct.s257) align 32 %agg.result, ptr arm64ec_argsize(288) %x) {
; CHECK-LABEL: callstruct257:
; CHECK:       .seh_proc callstruct257
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x19, x20, [sp, #-48]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_regp_x x19, 48
; CHECK-NEXT:    str x27, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x27, 16
; CHECK-NEXT:    stp x29, x30, [sp, #24] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 24
; CHECK-NEXT:    add x29, sp, #24
; CHECK-NEXT:    .seh_add_fp 24
; CHECK-NEXT:    sub x9, sp, #304
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x19, x8
; CHECK-NEXT:    adrp x8, pfnstruct257
; CHECK-NEXT:    mov x1, x0
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    mov w2, #288
; CHECK-NEXT:    ldr x20, [x8, :lo12:pfnstruct257]
; CHECK-NEXT:    bl "#memcpy"
; CHECK-NEXT:    adrp x8, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m288a32$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m288a32$i8)
; CHECK-NEXT:    mov x11, x20
; CHECK-NEXT:    ldr x8, [x8, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    mov x8, x19
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    sub sp, x29, #24
; CHECK-NEXT:    .seh_add_fp 24
; CHECK-NEXT:    ldp x29, x30, [sp, #24] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 24
; CHECK-NEXT:    ldr x27, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x27, 16
; CHECK-NEXT:    ldp x19, x20, [sp], #48 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_regp_x x19, 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s257, align 32
  %0 = load ptr, ptr @pfnstruct257, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.tmp, ptr align 32 %x, i64 288, i1 false)
  call arm64ec_argsize(288) void %0(ptr sret(%struct.s257) align 32 %agg.result, ptr arm64ec_argsize(288) %agg.tmp)
  ret void
}

define dso_local arm64ec_argsize(8) %struct.f2 @callstructf2([2 x float] arm64ec_argsize(8) %x.coerce) {
; CHECK-LABEL: callstructf2:
; CHECK:       .seh_proc callstructf2
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructf2
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$F8$F8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$F8$F8)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructf2]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructf2, align 8
  %call = tail call arm64ec_argsize(8) %struct.f2 %0([2 x float] arm64ec_argsize(8) %x.coerce) #2
  %1 = extractvalue %struct.f2 %call, 0
  %.fca.0.extract = extractvalue [2 x float] %1, 0
  %.fca.1.extract = extractvalue [2 x float] %1, 1
  %.fca.0.0.insert = insertvalue %struct.f2 poison, float %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.f2 %.fca.0.0.insert, float %.fca.1.extract, 0, 1
  ret %struct.f2 %.fca.0.1.insert
}

define dso_local arm64ec_argsize(64) void @callstructf3(ptr sret(%struct.f3) align 64 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstructf3:
; CHECK:       .seh_proc callstructf3
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffc0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructf3
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructf3]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.f3, align 64
  %0 = load ptr, ptr @pfnstructf3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.tmp, ptr align 64 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.f3) align 64 %agg.result, ptr arm64ec_argsize(64) %agg.tmp) #2
  ret void
}

define dso_local arm64ec_argsize(32) void @callstructf4(ptr sret(%struct.f4) align 32 %agg.result, ptr arm64ec_argsize(32) %x) {
; CHECK-LABEL: callstructf4:
; CHECK:       .seh_proc callstructf4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #48
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructf4
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructf4]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.f4, align 32
  %0 = load ptr, ptr @pfnstructf4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.tmp, ptr align 32 %x, i64 32, i1 false)
  call arm64ec_argsize(32) void %0(ptr sret(%struct.f4) align 32 %agg.result, ptr arm64ec_argsize(32) %agg.tmp) #2
  ret void
}

define dso_local arm64ec_argsize(32) void @callstructf5(ptr sret(%struct.f5) align 32 %agg.result, ptr arm64ec_argsize(32) %x) {
; CHECK-LABEL: callstructf5:
; CHECK:       .seh_proc callstructf5
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #48
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructf5
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructf5]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m32a32$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.f5, align 32
  %0 = load ptr, ptr @pfnstructf5, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.tmp, ptr align 32 %x, i64 32, i1 false)
  call arm64ec_argsize(32) void %0(ptr sret(%struct.f5) align 32 %agg.result, ptr arm64ec_argsize(32) %agg.tmp) #2
  ret void
}

define dso_local arm64ec_argsize(64) void @callstructd2(ptr sret(%struct.d2) align 64 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstructd2:
; CHECK:       .seh_proc callstructd2
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffc0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructd2
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructd2]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.d2, align 64
  %0 = load ptr, ptr @pfnstructd2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.tmp, ptr align 64 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.d2) align 64 %agg.result, ptr arm64ec_argsize(64) %agg.tmp) #2
  ret void
}

define dso_local arm64ec_argsize(64) void @callstructd3(ptr sret(%struct.d3) align 64 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstructd3:
; CHECK:       .seh_proc callstructd3
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffc0
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructd3
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructd3]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64a64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.d3, align 64
  %0 = load ptr, ptr @pfnstructd3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.tmp, ptr align 64 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.d3) align 64 %agg.result, ptr arm64ec_argsize(64) %agg.tmp) #2
  ret void
}
