; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=arm64ec-pc-windows-msvc < %s | FileCheck %s

%struct.s17 = type { [17 x i8] }
%struct.s32 = type { [32 x i8] }
%struct.s33 = type { [33 x i8] }
%struct.s64 = type { [64 x i8] }
%struct.s65 = type { [65 x i8] }
%struct.s128 = type { [128 x i8] }
%struct.s133 = type { [133 x i8] }
%struct.s192 = type { [192 x i8] }
%struct.s223 = type { [223 x i8] }
%struct.s256 = type { [256 x i8] }
%struct.s257 = type { [257 x i8] }
%struct.f2 = type { [2 x float] }
%struct.f3 = type { [3 x float] }
%struct.f4 = type { [4 x float] }
%struct.d2 = type { [2 x double] }
%struct.d3 = type { [3 x double] }
%struct.d4 = type { [4 x double] }
%struct.f5 = type { [5 x float] }
%struct.d5 = type { [5 x double] }

@pfnstruct1 = global ptr null, align 8
@pfnstruct2 = global ptr null, align 8
@pfnstruct3 = global ptr null, align 8
@pfnstruct4 = global ptr null, align 8
@pfnstruct5 = global ptr null, align 8
@pfnstruct6 = global ptr null, align 8
@pfnstruct7 = global ptr null, align 8
@pfnstruct8 = global ptr null, align 8
@pfnstruct9 = global ptr null, align 8
@pfnstruct10 = global ptr null, align 8
@pfnstruct11 = global ptr null, align 8
@pfnstruct12 = global ptr null, align 8
@pfnstruct13 = global ptr null, align 8
@pfnstruct14 = global ptr null, align 8
@pfnstruct15 = global ptr null, align 8
@pfnstruct16 = global ptr null, align 8
@pfnstruct17 = global ptr null, align 8
@pfnstruct32 = global ptr null, align 8
@pfnstruct33 = global ptr null, align 8
@pfnstruct64 = global ptr null, align 8
@pfnstruct65 = global ptr null, align 8
@pfnstruct128 = global ptr null, align 8
@pfnstruct133 = global ptr null, align 8
@pfnstruct192 = global ptr null, align 8
@pfnstruct223 = global ptr null, align 8
@pfnstruct256 = global ptr null, align 8
@pfnstruct257 = global ptr null, align 8
@pfnstructf2 = global ptr null, align 8
@pfnstructf3 = global ptr null, align 8
@pfnstructf4 = global ptr null, align 8
@pfnstructf5 = global ptr null, align 8
@pfnstructd2 = global ptr null, align 8
@pfnstructd3 = global ptr null, align 8
@pfnstructd4 = global ptr null, align 8
@pfnstructd5 = global ptr null, align 8

define dso_local arm64ec_argsize(1) i8 @callstruct1(i64 arm64ec_argsize(1) %x.coerce) {
; CHECK-LABEL: callstruct1:
; CHECK:       .seh_proc callstruct1
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct1
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m1$m1)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m1$m1)
; CHECK-NEXT:    and x0, x0, #0xff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct1]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct1, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 255
  %call = tail call arm64ec_argsize(1) i8 %0(i64 arm64ec_argsize(1) %coerce.dive1.coerce.0.insert.ext)
  ret i8 %call
}


declare void @llvm.memcpy.p0.p0.i64(ptr writeonly, ptr, i64, i1 immarg)


define dso_local arm64ec_argsize(2) i16 @callstruct2(i64 arm64ec_argsize(2) %x.coerce) {
; CHECK-LABEL: callstruct2:
; CHECK:       .seh_proc callstruct2
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct2
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m2$m2)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m2$m2)
; CHECK-NEXT:    and x0, x0, #0xffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct2]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct2, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 65535
  %call = tail call arm64ec_argsize(2) i16 %0(i64 arm64ec_argsize(2) %coerce.dive1.coerce.0.insert.ext)
  ret i16 %call
}


define dso_local arm64ec_argsize(3) i24 @callstruct3(i64 arm64ec_argsize(3) %x.coerce) {
; CHECK-LABEL: callstruct3:
; CHECK:       .seh_proc callstruct3
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct3
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m3$m3)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m3$m3)
; CHECK-NEXT:    and x0, x0, #0xffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct3]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct3, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 16777215
  %call = tail call arm64ec_argsize(3) i24 %0(i64 arm64ec_argsize(3) %coerce.dive1.coerce.0.insert.ext)
  ret i24 %call
}


define dso_local arm64ec_argsize(4) i32 @callstruct4(i64 arm64ec_argsize(4) %x.coerce) {
; CHECK-LABEL: callstruct4:
; CHECK:       .seh_proc callstruct4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct4
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m$m)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m$m)
; CHECK-NEXT:    and x0, x0, #0xffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct4]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct4, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 4294967295
  %call = tail call arm64ec_argsize(4) i32 %0(i64 arm64ec_argsize(4) %coerce.dive1.coerce.0.insert.ext)
  ret i32 %call
}


define dso_local arm64ec_argsize(5) i40 @callstruct5(i64 arm64ec_argsize(5) %x.coerce) {
; CHECK-LABEL: callstruct5:
; CHECK:       .seh_proc callstruct5
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct5
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m5$m5)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m5$m5)
; CHECK-NEXT:    and x0, x0, #0xffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct5]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct5, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 1099511627775
  %call = tail call arm64ec_argsize(5) i40 %0(i64 arm64ec_argsize(5) %coerce.dive1.coerce.0.insert.ext)
  ret i40 %call
}


define dso_local arm64ec_argsize(6) i48 @callstruct6(i64 arm64ec_argsize(6) %x.coerce) {
; CHECK-LABEL: callstruct6:
; CHECK:       .seh_proc callstruct6
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct6
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m6$m6)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m6$m6)
; CHECK-NEXT:    and x0, x0, #0xffffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct6]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct6, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 281474976710655
  %call = tail call arm64ec_argsize(6) i48 %0(i64 arm64ec_argsize(6) %coerce.dive1.coerce.0.insert.ext)
  ret i48 %call
}


define dso_local arm64ec_argsize(7) i56 @callstruct7(i64 arm64ec_argsize(7) %x.coerce) {
; CHECK-LABEL: callstruct7:
; CHECK:       .seh_proc callstruct7
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct7
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m7$m7)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m7$m7)
; CHECK-NEXT:    and x0, x0, #0xffffffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct7]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct7, align 8
  %coerce.dive1.coerce.0.insert.ext = and i64 %x.coerce, 72057594037927935
  %call = tail call arm64ec_argsize(7) i56 %0(i64 arm64ec_argsize(7) %coerce.dive1.coerce.0.insert.ext)
  ret i56 %call
}


define dso_local arm64ec_argsize(8) i64 @callstruct8(i64 arm64ec_argsize(8) %x.coerce) {
; CHECK-LABEL: callstruct8:
; CHECK:       .seh_proc callstruct8
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct8
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m8$m8)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct8]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct8, align 8
  %call = tail call arm64ec_argsize(8) i64 %0(i64 arm64ec_argsize(8) %x.coerce)
  ret i64 %call
}


define dso_local arm64ec_argsize(9) [2 x i64] @callstruct9([2 x i64] arm64ec_argsize(9) %x.coerce) {
; CHECK-LABEL: callstruct9:
; CHECK:       .seh_proc callstruct9
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct9
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m9$m9)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m9$m9)
; CHECK-NEXT:    and x1, x1, #0xff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct9]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct9, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 255
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(9) [2 x i64] %0([2 x i64] arm64ec_argsize(9) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 255
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(10) [2 x i64] @callstruct10([2 x i64] arm64ec_argsize(10) %x.coerce) {
; CHECK-LABEL: callstruct10:
; CHECK:       .seh_proc callstruct10
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct10
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m10$m10)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m10$m10)
; CHECK-NEXT:    and x1, x1, #0xffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct10]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct10, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 65535
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(10) [2 x i64] %0([2 x i64] arm64ec_argsize(10) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 65535
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(11) [2 x i64] @callstruct11([2 x i64] arm64ec_argsize(11) %x.coerce) {
; CHECK-LABEL: callstruct11:
; CHECK:       .seh_proc callstruct11
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct11
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m11$m11)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m11$m11)
; CHECK-NEXT:    and x1, x1, #0xffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct11]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct11, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 16777215
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(11) [2 x i64] %0([2 x i64] arm64ec_argsize(11) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 16777215
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(12) [2 x i64] @callstruct12([2 x i64] arm64ec_argsize(12) %x.coerce) {
; CHECK-LABEL: callstruct12:
; CHECK:       .seh_proc callstruct12
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct12
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m12$m12)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m12$m12)
; CHECK-NEXT:    and x1, x1, #0xffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct12]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct12, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 4294967295
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(12) [2 x i64] %0([2 x i64] arm64ec_argsize(12) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 4294967295
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(13) [2 x i64] @callstruct13([2 x i64] arm64ec_argsize(13) %x.coerce) {
; CHECK-LABEL: callstruct13:
; CHECK:       .seh_proc callstruct13
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct13
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m13$m13)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m13$m13)
; CHECK-NEXT:    and x1, x1, #0xffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct13]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct13, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 1099511627775
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(13) [2 x i64] %0([2 x i64] arm64ec_argsize(13) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 1099511627775
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(14) [2 x i64] @callstruct14([2 x i64] arm64ec_argsize(14) %x.coerce) {
; CHECK-LABEL: callstruct14:
; CHECK:       .seh_proc callstruct14
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct14
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m14$m14)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m14$m14)
; CHECK-NEXT:    and x1, x1, #0xffffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct14]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffffffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct14, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 281474976710655
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(14) [2 x i64] %0([2 x i64] arm64ec_argsize(14) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 281474976710655
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(15) [2 x i64] @callstruct15([2 x i64] arm64ec_argsize(15) %x.coerce) {
; CHECK-LABEL: callstruct15:
; CHECK:       .seh_proc callstruct15
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct15
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m15$m15)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m15$m15)
; CHECK-NEXT:    and x1, x1, #0xffffffffffffff
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct15]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    and x1, x1, #0xffffffffffffff
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %x.coerce.fca.1.extract = extractvalue [2 x i64] %x.coerce, 1
  %0 = load ptr, ptr @pfnstruct15, align 8
  %coerce.dive1.coerce.sroa.2.0.insert.ext = and i64 %x.coerce.fca.1.extract, 72057594037927935
  %.fca.1.insert6 = insertvalue [2 x i64] %x.coerce, i64 %coerce.dive1.coerce.sroa.2.0.insert.ext, 1
  %call = tail call arm64ec_argsize(15) [2 x i64] %0([2 x i64] arm64ec_argsize(15) %.fca.1.insert6)
  %call.fca.1.extract = extractvalue [2 x i64] %call, 1
  %coerce.dive4.coerce.sroa.2.0.insert.ext = and i64 %call.fca.1.extract, 72057594037927935
  %.fca.1.insert = insertvalue [2 x i64] %call, i64 %coerce.dive4.coerce.sroa.2.0.insert.ext, 1
  ret [2 x i64] %.fca.1.insert
}


define dso_local arm64ec_argsize(16) [2 x i64] @callstruct16([2 x i64] arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstruct16:
; CHECK:       .seh_proc callstruct16
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstruct16
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m16$m16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m16$m16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstruct16]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstruct16, align 8
  %call = tail call arm64ec_argsize(16) [2 x i64] %0([2 x i64] arm64ec_argsize(16) %x.coerce)
  ret [2 x i64] %call
}


define dso_local arm64ec_argsize(17) void @callstruct17(ptr sret(%struct.s17) align 1 %agg.result, ptr arm64ec_argsize(17) %x) {
; CHECK-LABEL: callstruct17:
; CHECK:       .seh_proc callstruct17
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    str x30, [sp, #32] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 32
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct17
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct17]
; CHECK-NEXT:    ldrb w9, [x0, #16]
; CHECK-NEXT:    str q0, [sp]
; CHECK-NEXT:    ldr x12, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m17$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m17$i8)
; CHECK-NEXT:    strb w9, [sp, #16]
; CHECK-NEXT:    blr x12
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #32] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 32
; CHECK-NEXT:    add sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s17, align 1
  %0 = load ptr, ptr @pfnstruct17, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 17, i1 false)
  call arm64ec_argsize(17) void %0(ptr sret(%struct.s17) align 1 %agg.result, ptr arm64ec_argsize(17) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(32) void @callstruct32(ptr sret(%struct.s32) align 1 %agg.result, ptr arm64ec_argsize(32) %x) {
; CHECK-LABEL: callstruct32:
; CHECK:       .seh_proc callstruct32
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    str x30, [sp, #32] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 32
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct32
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m32$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m32$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #32] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 32
; CHECK-NEXT:    add sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s32, align 1
  %0 = load ptr, ptr @pfnstruct32, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 32, i1 false)
  call arm64ec_argsize(32) void %0(ptr sret(%struct.s32) align 1 %agg.result, ptr arm64ec_argsize(32) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(33) void @callstruct33(ptr sret(%struct.s33) align 1 %agg.result, ptr arm64ec_argsize(33) %x) {
; CHECK-LABEL: callstruct33:
; CHECK:       .seh_proc callstruct33
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    str x30, [sp, #48] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct33
; CHECK-NEXT:    ldrb w10, [x0, #32]
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    strb w10, [sp, #32]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m33$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m33$i8)
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct33]
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #48] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 48
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s33, align 1
  %0 = load ptr, ptr @pfnstruct33, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 33, i1 false)
  call arm64ec_argsize(33) void %0(ptr sret(%struct.s33) align 1 %agg.result, ptr arm64ec_argsize(33) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(64) void @callstruct64(ptr sret(%struct.s64) align 1 %agg.result, ptr arm64ec_argsize(64) %x) {
; CHECK-LABEL: callstruct64:
; CHECK:       .seh_proc callstruct64
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #80
; CHECK-NEXT:    .seh_stackalloc 80
; CHECK-NEXT:    str x30, [sp, #64] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 64
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct64
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct64]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m64$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m64$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #64] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 64
; CHECK-NEXT:    add sp, sp, #80
; CHECK-NEXT:    .seh_stackalloc 80
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s64, align 1
  %0 = load ptr, ptr @pfnstruct64, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 64, i1 false)
  call arm64ec_argsize(64) void %0(ptr sret(%struct.s64) align 1 %agg.result, ptr arm64ec_argsize(64) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(65) void @callstruct65(ptr sret(%struct.s65) align 1 %agg.result, ptr arm64ec_argsize(65) %x) {
; CHECK-LABEL: callstruct65:
; CHECK:       .seh_proc callstruct65
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #96
; CHECK-NEXT:    .seh_stackalloc 96
; CHECK-NEXT:    str x30, [sp, #80] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 80
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstruct65
; CHECK-NEXT:    ldrb w10, [x0, #64]
; CHECK-NEXT:    ldp q0, q1, [x0, #32]
; CHECK-NEXT:    adrp x12, __os_arm64x_check_icall
; CHECK-NEXT:    strb w10, [sp, #64]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m65$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m65$i8)
; CHECK-NEXT:    ldp q3, q2, [x0]
; CHECK-NEXT:    stp q0, q1, [sp, #32]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct65]
; CHECK-NEXT:    stp q3, q2, [sp]
; CHECK-NEXT:    ldr x9, [x12, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #80] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 80
; CHECK-NEXT:    add sp, sp, #96
; CHECK-NEXT:    .seh_stackalloc 96
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s65, align 1
  %0 = load ptr, ptr @pfnstruct65, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 65, i1 false)
  call arm64ec_argsize(65) void %0(ptr sret(%struct.s65) align 1 %agg.result, ptr arm64ec_argsize(65) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(128) void @callstruct128(ptr sret(%struct.s128) align 1 %agg.result, ptr arm64ec_argsize(128) %x) {
; CHECK-LABEL: callstruct128:
; CHECK:       .seh_proc callstruct128
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #144
; CHECK-NEXT:    .seh_stackalloc 144
; CHECK-NEXT:    str x30, [sp, #128] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 128
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    ldp q0, q1, [x0, #64]
; CHECK-NEXT:    adrp x9, pfnstruct128
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q2, q3, [x0, #96]
; CHECK-NEXT:    stp q0, q1, [sp, #64]
; CHECK-NEXT:    ldp q0, q4, [x0]
; CHECK-NEXT:    stp q2, q3, [sp, #96]
; CHECK-NEXT:    ldp q1, q2, [x0, #32]
; CHECK-NEXT:    stp q0, q4, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct128]
; CHECK-NEXT:    stp q1, q2, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m128$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m128$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #128] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 128
; CHECK-NEXT:    add sp, sp, #144
; CHECK-NEXT:    .seh_stackalloc 144
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s128, align 1
  %0 = load ptr, ptr @pfnstruct128, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 128, i1 false)
  call arm64ec_argsize(128) void %0(ptr sret(%struct.s128) align 1 %agg.result, ptr arm64ec_argsize(128) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(133) void @callstruct133(ptr sret(%struct.s133) align 1 %agg.result, ptr arm64ec_argsize(133) %x) {
; CHECK-LABEL: callstruct133:
; CHECK:       .seh_proc callstruct133
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #160
; CHECK-NEXT:    .seh_stackalloc 160
; CHECK-NEXT:    str x30, [sp, #144] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 144
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    ldp q0, q1, [x0, #96]
; CHECK-NEXT:    adrp x9, pfnstruct133
; CHECK-NEXT:    adrp x12, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q2, q3, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp, #96]
; CHECK-NEXT:    ldur x10, [x0, #125]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    ldp q1, q0, [x0, #64]
; CHECK-NEXT:    stur x10, [sp, #125]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m133$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m133$i8)
; CHECK-NEXT:    ldp q3, q2, [x0]
; CHECK-NEXT:    stp q1, q0, [sp, #64]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct133]
; CHECK-NEXT:    stp q3, q2, [sp]
; CHECK-NEXT:    ldr x9, [x12, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #144] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 144
; CHECK-NEXT:    add sp, sp, #160
; CHECK-NEXT:    .seh_stackalloc 160
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s133, align 1
  %0 = load ptr, ptr @pfnstruct133, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 133, i1 false)
  call arm64ec_argsize(133) void %0(ptr sret(%struct.s133) align 1 %agg.result, ptr arm64ec_argsize(133) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(192) void @callstruct192(ptr sret(%struct.s192) align 1 %agg.result, ptr arm64ec_argsize(192) %x) {
; CHECK-LABEL: callstruct192:
; CHECK:       .seh_proc callstruct192
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #208
; CHECK-NEXT:    .seh_stackalloc 208
; CHECK-NEXT:    str x30, [sp, #192] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 192
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    ldp q0, q1, [x0, #128]
; CHECK-NEXT:    adrp x9, pfnstruct192
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q2, q3, [x0, #160]
; CHECK-NEXT:    stp q0, q1, [sp, #128]
; CHECK-NEXT:    ldp q0, q1, [x0, #64]
; CHECK-NEXT:    stp q2, q3, [sp, #160]
; CHECK-NEXT:    ldp q2, q3, [x0, #96]
; CHECK-NEXT:    stp q0, q1, [sp, #64]
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    stp q2, q3, [sp, #96]
; CHECK-NEXT:    ldp q4, q2, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct192]
; CHECK-NEXT:    stp q4, q2, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m192$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m192$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #192] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 192
; CHECK-NEXT:    add sp, sp, #208
; CHECK-NEXT:    .seh_stackalloc 208
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s192, align 1
  %0 = load ptr, ptr @pfnstruct192, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 192, i1 false)
  call arm64ec_argsize(192) void %0(ptr sret(%struct.s192) align 1 %agg.result, ptr arm64ec_argsize(192) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(223) void @callstruct223(ptr sret(%struct.s223) align 1 %agg.result, ptr arm64ec_argsize(223) %x) {
; CHECK-LABEL: callstruct223:
; CHECK:       .seh_proc callstruct223
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #240
; CHECK-NEXT:    .seh_stackalloc 240
; CHECK-NEXT:    str x30, [sp, #224] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 224
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    ldp q0, q1, [x0, #160]
; CHECK-NEXT:    adrp x9, pfnstruct223
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    stp q0, q1, [sp, #160]
; CHECK-NEXT:    ldr q2, [x0, #192]
; CHECK-NEXT:    ldp q0, q1, [x0, #96]
; CHECK-NEXT:    str q2, [sp, #192]
; CHECK-NEXT:    ldur q3, [x0, #207]
; CHECK-NEXT:    stp q0, q1, [sp, #96]
; CHECK-NEXT:    ldp q0, q1, [x0, #32]
; CHECK-NEXT:    stur q3, [sp, #207]
; CHECK-NEXT:    ldp q2, q3, [x0, #128]
; CHECK-NEXT:    stp q0, q1, [sp, #32]
; CHECK-NEXT:    stp q2, q3, [sp, #128]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct223]
; CHECK-NEXT:    ldp q2, q3, [x0, #64]
; CHECK-NEXT:    ldp q4, q0, [x0]
; CHECK-NEXT:    stp q2, q3, [sp, #64]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m223$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m223$i8)
; CHECK-NEXT:    stp q4, q0, [sp]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #224] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 224
; CHECK-NEXT:    add sp, sp, #240
; CHECK-NEXT:    .seh_stackalloc 240
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s223, align 1
  %0 = load ptr, ptr @pfnstruct223, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 223, i1 false)
  call arm64ec_argsize(223) void %0(ptr sret(%struct.s223) align 1 %agg.result, ptr arm64ec_argsize(223) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(256) void @callstruct256(ptr sret(%struct.s256) align 1 %agg.result, ptr arm64ec_argsize(256) %x) {
; CHECK-LABEL: callstruct256:
; CHECK:       .seh_proc callstruct256
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #272
; CHECK-NEXT:    .seh_stackalloc 272
; CHECK-NEXT:    stp x29, x30, [sp, #256] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 256
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    ldp q0, q1, [x0, #192]
; CHECK-NEXT:    adrp x9, pfnstruct256
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldp q2, q3, [x0, #224]
; CHECK-NEXT:    stp q0, q1, [sp, #192]
; CHECK-NEXT:    ldp q0, q1, [x0, #128]
; CHECK-NEXT:    stp q2, q3, [sp, #224]
; CHECK-NEXT:    ldp q2, q3, [x0, #160]
; CHECK-NEXT:    stp q0, q1, [sp, #128]
; CHECK-NEXT:    ldp q0, q1, [x0, #64]
; CHECK-NEXT:    stp q2, q3, [sp, #160]
; CHECK-NEXT:    ldp q2, q3, [x0, #96]
; CHECK-NEXT:    stp q0, q1, [sp, #64]
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    stp q2, q3, [sp, #96]
; CHECK-NEXT:    ldp q4, q2, [x0, #32]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstruct256]
; CHECK-NEXT:    stp q4, q2, [sp, #32]
; CHECK-NEXT:    ldr x9, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m256$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m256$i8)
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp, #256] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 256
; CHECK-NEXT:    add sp, sp, #272
; CHECK-NEXT:    .seh_stackalloc 272
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s256, align 1
  %0 = load ptr, ptr @pfnstruct256, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 256, i1 false)
  call arm64ec_argsize(256) void %0(ptr sret(%struct.s256) align 1 %agg.result, ptr arm64ec_argsize(256) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(257) void @callstruct257(ptr sret(%struct.s257) align 1 %agg.result, ptr arm64ec_argsize(257) %x) {
; CHECK-LABEL: callstruct257:
; CHECK:       .seh_proc callstruct257
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #304
; CHECK-NEXT:    .seh_stackalloc 304
; CHECK-NEXT:    stp x19, x20, [sp, #272] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_regp x19, 272
; CHECK-NEXT:    stp x29, x30, [sp, #288] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 288
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x19, x8
; CHECK-NEXT:    adrp x8, pfnstruct257
; CHECK-NEXT:    mov x1, x0
; CHECK-NEXT:    add x0, sp, #8
; CHECK-NEXT:    mov w2, #257
; CHECK-NEXT:    ldr x20, [x8, :lo12:pfnstruct257]
; CHECK-NEXT:    bl "#memcpy"
; CHECK-NEXT:    adrp x8, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$m257$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$m257$i8)
; CHECK-NEXT:    mov x11, x20
; CHECK-NEXT:    ldr x8, [x8, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    add x0, sp, #8
; CHECK-NEXT:    mov x8, x19
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp, #288] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 288
; CHECK-NEXT:    ldp x19, x20, [sp, #272] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_regp x19, 272
; CHECK-NEXT:    add sp, sp, #304
; CHECK-NEXT:    .seh_stackalloc 304
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.s257, align 1
  %0 = load ptr, ptr @pfnstruct257, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 257, i1 false)
  call arm64ec_argsize(257) void %0(ptr sret(%struct.s257) align 1 %agg.result, ptr arm64ec_argsize(257) %agg.tmp)
  ret void
}



define dso_local arm64ec_argsize(8) %struct.f2 @callstructf2([2 x float] arm64ec_argsize(8) %x.coerce) {
; CHECK-LABEL: callstructf2:
; CHECK:       .seh_proc callstructf2
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructf2
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$F8$F8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$F8$F8)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructf2]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructf2, align 8
  %call = tail call arm64ec_argsize(8) %struct.f2 %0([2 x float] arm64ec_argsize(8) %x.coerce)
  %1 = extractvalue %struct.f2 %call, 0
  %.fca.0.extract = extractvalue [2 x float] %1, 0
  %.fca.1.extract = extractvalue [2 x float] %1, 1
  %.fca.0.0.insert = insertvalue %struct.f2 poison, float %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.f2 %.fca.0.0.insert, float %.fca.1.extract, 0, 1
  ret %struct.f2 %.fca.0.1.insert
}


define dso_local arm64ec_argsize(12) %struct.f3 @callstructf3([3 x float] arm64ec_argsize(12) %x.coerce) {
; CHECK-LABEL: callstructf3:
; CHECK:       .seh_proc callstructf3
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructf3
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$F12$F12)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$F12$F12)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructf3]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructf3, align 8
  %call = tail call arm64ec_argsize(12) %struct.f3 %0([3 x float] arm64ec_argsize(12) %x.coerce)
  %1 = extractvalue %struct.f3 %call, 0
  %.fca.0.extract = extractvalue [3 x float] %1, 0
  %.fca.1.extract = extractvalue [3 x float] %1, 1
  %.fca.2.extract = extractvalue [3 x float] %1, 2
  %.fca.0.0.insert = insertvalue %struct.f3 poison, float %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.f3 %.fca.0.0.insert, float %.fca.1.extract, 0, 1
  %.fca.0.2.insert = insertvalue %struct.f3 %.fca.0.1.insert, float %.fca.2.extract, 0, 2
  ret %struct.f3 %.fca.0.2.insert
}


define dso_local arm64ec_argsize(16) %struct.f4 @callstructf4([4 x float] arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstructf4:
; CHECK:       .seh_proc callstructf4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructf4
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$F16$F16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$F16$F16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructf4]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructf4, align 8
  %call = tail call arm64ec_argsize(16) %struct.f4 %0([4 x float] arm64ec_argsize(16) %x.coerce)
  %1 = extractvalue %struct.f4 %call, 0
  %.fca.0.extract = extractvalue [4 x float] %1, 0
  %.fca.1.extract = extractvalue [4 x float] %1, 1
  %.fca.2.extract = extractvalue [4 x float] %1, 2
  %.fca.3.extract = extractvalue [4 x float] %1, 3
  %.fca.0.0.insert = insertvalue %struct.f4 poison, float %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.f4 %.fca.0.0.insert, float %.fca.1.extract, 0, 1
  %.fca.0.2.insert = insertvalue %struct.f4 %.fca.0.1.insert, float %.fca.2.extract, 0, 2
  %.fca.0.3.insert = insertvalue %struct.f4 %.fca.0.2.insert, float %.fca.3.extract, 0, 3
  ret %struct.f4 %.fca.0.3.insert
}


define dso_local arm64ec_argsize(20) void @callstructf5(ptr sret(%struct.f5) align 1 %agg.result, ptr arm64ec_argsize(20) %x) {
; CHECK-LABEL: callstructf5:
; CHECK:       .seh_proc callstructf5
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    str x30, [sp, #32] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 32
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructf5
; CHECK-NEXT:    adrp x10, __os_arm64x_check_icall
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructf5]
; CHECK-NEXT:    ldr w9, [x0, #16]
; CHECK-NEXT:    str q0, [sp]
; CHECK-NEXT:    ldr x12, [x10, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$F20$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$F20$i8)
; CHECK-NEXT:    str w9, [sp, #16]
; CHECK-NEXT:    blr x12
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #32] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 32
; CHECK-NEXT:    add sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.f5, align 1
  %0 = load ptr, ptr @pfnstructf5, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 20, i1 false)
  call arm64ec_argsize(20) void %0(ptr sret(%struct.f5) align 1 %agg.result, ptr arm64ec_argsize(20) %agg.tmp)
  ret void
}


define dso_local arm64ec_argsize(16) %struct.d2 @callstructd2([2 x double] arm64ec_argsize(16) %x.coerce) {
; CHECK-LABEL: callstructd2:
; CHECK:       .seh_proc callstructd2
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructd2
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$D16$D16)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$D16$D16)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructd2]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructd2, align 8
  %call = tail call arm64ec_argsize(16) %struct.d2 %0([2 x double] arm64ec_argsize(16) %x.coerce)
  %1 = extractvalue %struct.d2 %call, 0
  %.fca.0.extract = extractvalue [2 x double] %1, 0
  %.fca.1.extract = extractvalue [2 x double] %1, 1
  %.fca.0.0.insert = insertvalue %struct.d2 poison, double %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.d2 %.fca.0.0.insert, double %.fca.1.extract, 0, 1
  ret %struct.d2 %.fca.0.1.insert
}


define dso_local arm64ec_argsize(24) %struct.d3 @callstructd3([3 x double] arm64ec_argsize(24) %x.coerce) {
; CHECK-LABEL: callstructd3:
; CHECK:       .seh_proc callstructd3
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructd3
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$D24$D24)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$D24$D24)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructd3]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructd3, align 8
  %call = tail call arm64ec_argsize(24) %struct.d3 %0([3 x double] arm64ec_argsize(24) %x.coerce)
  %1 = extractvalue %struct.d3 %call, 0
  %.fca.0.extract = extractvalue [3 x double] %1, 0
  %.fca.1.extract = extractvalue [3 x double] %1, 1
  %.fca.2.extract = extractvalue [3 x double] %1, 2
  %.fca.0.0.insert = insertvalue %struct.d3 poison, double %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.d3 %.fca.0.0.insert, double %.fca.1.extract, 0, 1
  %.fca.0.2.insert = insertvalue %struct.d3 %.fca.0.1.insert, double %.fca.2.extract, 0, 2
  ret %struct.d3 %.fca.0.2.insert
}


define dso_local arm64ec_argsize(32) %struct.d4 @callstructd4([4 x double] arm64ec_argsize(32) %x.coerce) {
; CHECK-LABEL: callstructd4:
; CHECK:       .seh_proc callstructd4
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x8, pfnstructd4
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$D32$D32)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$D32$D32)
; CHECK-NEXT:    ldr x11, [x8, :lo12:pfnstructd4]
; CHECK-NEXT:    ldr x8, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x30, 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    br x11
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %0 = load ptr, ptr @pfnstructd4, align 8
  %call = tail call arm64ec_argsize(32) %struct.d4 %0([4 x double] arm64ec_argsize(32) %x.coerce)
  %1 = extractvalue %struct.d4 %call, 0
  %.fca.0.extract = extractvalue [4 x double] %1, 0
  %.fca.1.extract = extractvalue [4 x double] %1, 1
  %.fca.2.extract = extractvalue [4 x double] %1, 2
  %.fca.3.extract = extractvalue [4 x double] %1, 3
  %.fca.0.0.insert = insertvalue %struct.d4 poison, double %.fca.0.extract, 0, 0
  %.fca.0.1.insert = insertvalue %struct.d4 %.fca.0.0.insert, double %.fca.1.extract, 0, 1
  %.fca.0.2.insert = insertvalue %struct.d4 %.fca.0.1.insert, double %.fca.2.extract, 0, 2
  %.fca.0.3.insert = insertvalue %struct.d4 %.fca.0.2.insert, double %.fca.3.extract, 0, 3
  ret %struct.d4 %.fca.0.3.insert
}


define dso_local arm64ec_argsize(40) void @callstructd5(ptr sret(%struct.d5) align 1 %agg.result, ptr arm64ec_argsize(40) %x) {
; CHECK-LABEL: callstructd5:
; CHECK:       .seh_proc callstructd5
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    str x30, [sp, #48] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 48
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x9, pfnstructd5
; CHECK-NEXT:    ldr x10, [x0, #32]
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    str x10, [sp, #32]
; CHECK-NEXT:    adrp x10, ($iexit_thunk$cdecl$D40$i8)
; CHECK-NEXT:    add x10, x10, :lo12:($iexit_thunk$cdecl$D40$i8)
; CHECK-NEXT:    ldr x11, [x9, :lo12:pfnstructd5]
; CHECK-NEXT:    adrp x9, __os_arm64x_check_icall
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    ldr x9, [x9, :lo12:__os_arm64x_check_icall]
; CHECK-NEXT:    blr x9
; CHECK-NEXT:    mov x0, sp
; CHECK-NEXT:    blr x11
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #48] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 48
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:
  %agg.tmp = alloca %struct.d5, align 1
  %0 = load ptr, ptr @pfnstructd5, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp, ptr align 1 %x, i64 40, i1 false)
  call arm64ec_argsize(40) void %0(ptr sret(%struct.d5) align 1 %agg.result, ptr arm64ec_argsize(40) %agg.tmp)
  ret void
}
