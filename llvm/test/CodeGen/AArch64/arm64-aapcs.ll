; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=arm64-linux-gnu -enable-misched=false -disable-post-ra < %s | FileCheck %s

@var = dso_local global i32 0, align 4

; CHECK-LABEL: @test_i128_align
define dso_local i128 @test_i128_align(i32, i128 %arg, i32 %after) {
; CHECK-LABEL: test_i128_align:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x1, x3
; CHECK-NEXT:    mov x0, x2
; CHECK-NEXT:    adrp x8, var
; CHECK-NEXT:    str w4, [x8, :lo12:var]
; CHECK-NEXT:    ret
  store i32 %after, i32* @var, align 4

  ret i128 %arg
}

; CHECK-LABEL: @test_i64x2_align
define [2 x i64] @test_i64x2_align(i32, [2 x i64] %arg, i32 %after) {
; CHECK-LABEL: test_i64x2_align:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x0, x1
; CHECK-NEXT:    adrp x8, var
; CHECK-NEXT:    str w3, [x8, :lo12:var]
; CHECK-NEXT:    mov x1, x2
; CHECK-NEXT:    ret
  store i32 %after, i32* @var, align 4

  ret [2 x i64] %arg
}

@var64 = dso_local global i64 0, align 8

; Check stack slots are 64-bit at all times.
define dso_local void @test_stack_slots([8 x i64], i1 %bool, i8 %char, i16 %short,
; CHECK-LABEL: test_stack_slots:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr w8, [sp, #24]
; CHECK-NEXT:    ldrh w9, [sp, #16]
; CHECK-NEXT:    ldrb w10, [sp, #8]
; CHECK-NEXT:    ldr x11, [sp, #32]
; CHECK-NEXT:    ldrb w12, [sp]
; CHECK-NEXT:    and w12, w12, #0x1
; CHECK-NEXT:    adrp x13, var64
; CHECK-NEXT:    str x12, [x13, :lo12:var64]
; CHECK-NEXT:    str x10, [x13, :lo12:var64]
; CHECK-NEXT:    str x9, [x13, :lo12:var64]
; CHECK-NEXT:    str x8, [x13, :lo12:var64]
; CHECK-NEXT:    str x11, [x13, :lo12:var64]
; CHECK-NEXT:    ret
                                i32 %int, i64 %long) {

  %ext_bool = zext i1 %bool to i64
  store volatile i64 %ext_bool, i64* @var64, align 8

  %ext_char = zext i8 %char to i64
  store volatile i64 %ext_char, i64* @var64, align 8

  %ext_short = zext i16 %short to i64
  store volatile i64 %ext_short, i64* @var64, align 8

  %ext_int = zext i32 %int to i64
  store volatile i64 %ext_int, i64* @var64, align 8

  store volatile i64 %long, i64* @var64, align 8

  ret void
}

; Make sure the callee does extensions (in the absence of zext/sext
; keyword on args) while we're here.

define dso_local void @test_extension(i1 %bool, i8 %char, i16 %short, i32 %int) {
; CHECK-LABEL: test_extension:
; CHECK:       // %bb.0:
; CHECK-NEXT:    // kill: def $w1 killed $w1 def $x1
; CHECK-NEXT:    and w8, w0, #0x1
; CHECK-NEXT:    adrp x9, var64
; CHECK-NEXT:    str x8, [x9, :lo12:var64]
; CHECK-NEXT:    sxtb x8, w1
; CHECK-NEXT:    str x8, [x9, :lo12:var64]
; CHECK-NEXT:    and w8, w2, #0xffff
; CHECK-NEXT:    str x8, [x9, :lo12:var64]
; CHECK-NEXT:    mov w8, w3
; CHECK-NEXT:    str x8, [x9, :lo12:var64]
; CHECK-NEXT:    ret
  %ext_bool = zext i1 %bool to i64
  store volatile i64 %ext_bool, i64* @var64

  %ext_char = sext i8 %char to i64
  store volatile i64 %ext_char, i64* @var64

  %ext_short = zext i16 %short to i64
  store volatile i64 %ext_short, i64* @var64

  %ext_int = zext i32 %int to i64
  store volatile i64 %ext_int, i64* @var64

  ret void
}

declare void @variadic(i32 %a, ...)

  ; Under AAPCS variadic functions have the same calling convention as
  ; others. The extra arguments should go in registers rather than on the stack.
define dso_local void @test_variadic() {
; CHECK-LABEL: test_variadic:
; CHECK:       // %bb.0:
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    mov w1, #1
; CHECK-NEXT:    fmov d0, #2.00000000
; CHECK-NEXT:    bl variadic
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
  call void(i32, ...) @variadic(i32 0, i64 1, double 2.0)
  ret void
}

; We weren't marking x7 as used after deciding that the i128 didn't fit into
; registers and putting the first half on the stack, so the *second* half went
; into x7. Yuck!
define dso_local i128 @test_i128_shadow([7 x i64] %x0_x6, i128 %sp) {
; CHECK-LABEL: test_i128_shadow:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldp x0, x1, [sp]
; CHECK-NEXT:    ret

  ret i128 %sp
}

; This test is to check if fp128 can be correctly handled on stack.
define fp128 @test_fp128([8 x float] %arg0, fp128 %arg1) {
; CHECK-LABEL: test_fp128:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [sp]
; CHECK-NEXT:    ret
  ret fp128 %arg1
}

; Check if VPR can be correctly pass by stack.
define dso_local <2 x double> @test_vreg_stack([8 x <2 x double>], <2 x double> %varg_stack) {
; CHECK-LABEL: test_vreg_stack:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ldr q0, [sp]
; CHECK-NEXT:    ret
entry:
  ret <2 x double> %varg_stack;
}

; Check that f16 can be passed and returned (ACLE 2.0 extension)
define half @test_half(float, half %arg) {
; CHECK-LABEL: test_half:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov s0, s1
; CHECK-NEXT:    ret
  ret half %arg;
}

; Check that f16 constants are materialized correctly
define half @test_half_const() {
; CHECK-LABEL: test_half_const:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, .LCPI9_0
; CHECK-NEXT:    ldr h0, [x8, :lo12:.LCPI9_0]
; CHECK-NEXT:    ret
  ret half 0xH4248
}

; Check that v4f16 can be passed and returned in registers
define dso_local <4 x half> @test_v4_half_register(float, <4 x half> %arg) {
; CHECK-LABEL: test_v4_half_register:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov d0, d1
; CHECK-NEXT:    ret
  ret <4 x half> %arg;
}

; Check that v8f16 can be passed and returned in registers
define dso_local <8 x half> @test_v8_half_register(float, <8 x half> %arg) {
; CHECK-LABEL: test_v8_half_register:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov v0.16b, v1.16b
; CHECK-NEXT:    ret
  ret <8 x half> %arg;
}

; Check that v4f16 can be passed and returned on the stack
define dso_local <4 x half> @test_v4_half_stack([8 x <2 x double>], <4 x half> %arg) {
; CHECK-LABEL: test_v4_half_stack:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr d0, [sp]
; CHECK-NEXT:    ret
  ret <4 x half> %arg;
}

; Check that v8f16 can be passed and returned on the stack
define dso_local <8 x half> @test_v8_half_stack([8 x <2 x double>], <8 x half> %arg) {
; CHECK-LABEL: test_v8_half_stack:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [sp]
; CHECK-NEXT:    ret
  ret <8 x half> %arg;
}
