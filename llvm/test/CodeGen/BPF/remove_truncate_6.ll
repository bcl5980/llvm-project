; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -march=bpf -verify-machineinstrs | FileCheck %s
; RUN: llc < %s -march=bpf -mattr=+alu32 -verify-machineinstrs | FileCheck --check-prefix=CHECK-32 %s
;
; void cal1(unsigned short *a, unsigned long *b, unsigned int k)
; {
;   unsigned short e;
;
;   e = *a;
;   for (unsigned int i = 0; i < k; i++) {
;     b[i] = e;
;     e = ~e;
;   }
; }
;
; void cal2(unsigned short *a, unsigned int *b, unsigned int k)
; {
;   unsigned short e;
;
;   e = *a;
;   for (unsigned int i = 0; i < k; i++) {
;     b[i] = e;
;     e = ~e;
;   }
; }

; Function Attrs: nofree norecurse nounwind optsize
define dso_local void @cal1(i16* nocapture readonly %a, i64* nocapture %b, i32 %k) local_unnamed_addr #0 {
; CHECK-LABEL: cal1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    r3 <<= 32
; CHECK-NEXT:    r3 >>= 32
; CHECK-NEXT:    if r3 == 0 goto LBB0_3
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    r1 = *(u16 *)(r1 + 0)
; CHECK-NEXT:  LBB0_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    r4 = r1
; CHECK-NEXT:    r4 &= 65535
; CHECK-NEXT:    *(u64 *)(r2 + 0) = r4
; CHECK-NEXT:    r2 += 8
; CHECK-NEXT:    r1 ^= -1
; CHECK-NEXT:    r3 += -1
; CHECK-NEXT:    if r3 == 0 goto LBB0_3
; CHECK-NEXT:    goto LBB0_2
; CHECK-NEXT:  LBB0_3: # %for.cond.cleanup
; CHECK-NEXT:    exit
;
; CHECK-32-LABEL: cal1:
; CHECK-32:       # %bb.0: # %entry
; CHECK-32-NEXT:    w4 = 1
; CHECK-32-NEXT:    r3 = w3
; CHECK-32-NEXT:    if r3 == 0 goto LBB0_2
; CHECK-32-NEXT:  # %bb.1: # %entry
; CHECK-32-NEXT:    w4 = 0
; CHECK-32-NEXT:  LBB0_2: # %entry
; CHECK-32-NEXT:    w4 &= 1
; CHECK-32-NEXT:    if r4 != 0 goto LBB0_5
; CHECK-32-NEXT:  # %bb.3: # %for.body.preheader
; CHECK-32-NEXT:    w1 = *(u16 *)(r1 + 0)
; CHECK-32-NEXT:  LBB0_4: # %for.body
; CHECK-32-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-32-NEXT:    w4 = w1
; CHECK-32-NEXT:    w4 &= 65535
; CHECK-32-NEXT:    *(u64 *)(r2 + 0) = r4
; CHECK-32-NEXT:    r2 += 8
; CHECK-32-NEXT:    w1 ^= -1
; CHECK-32-NEXT:    r3 += -1
; CHECK-32-NEXT:    if r3 == 0 goto LBB0_5
; CHECK-32-NEXT:    goto LBB0_4
; CHECK-32-NEXT:  LBB0_5: # %for.cond.cleanup
; CHECK-32-NEXT:    exit
entry:
  %cmp8 = icmp eq i32 %k, 0
  br i1 %cmp8, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %0 = load i16, i16* %a, align 2
  %wide.trip.count = zext i32 %k to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %e.09 = phi i16 [ %0, %for.body.preheader ], [ %neg, %for.body ]
  %conv = zext i16 %e.09 to i64
  %arrayidx = getelementptr inbounds i64, i64* %b, i64 %indvars.iv
  store i64 %conv, i64* %arrayidx, align 8
  %neg = xor i16 %e.09, -1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nounwind optsize
define dso_local void @cal2(i16* nocapture readonly %a, i32* nocapture %b, i32 %k) local_unnamed_addr #0 {
; CHECK-LABEL: cal2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    r3 <<= 32
; CHECK-NEXT:    r3 >>= 32
; CHECK-NEXT:    if r3 == 0 goto LBB1_3
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    r1 = *(u16 *)(r1 + 0)
; CHECK-NEXT:  LBB1_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    r4 = r1
; CHECK-NEXT:    r4 &= 65535
; CHECK-NEXT:    *(u32 *)(r2 + 0) = r4
; CHECK-NEXT:    r2 += 4
; CHECK-NEXT:    r1 ^= -1
; CHECK-NEXT:    r3 += -1
; CHECK-NEXT:    if r3 == 0 goto LBB1_3
; CHECK-NEXT:    goto LBB1_2
; CHECK-NEXT:  LBB1_3: # %for.cond.cleanup
; CHECK-NEXT:    exit
;
; CHECK-32-LABEL: cal2:
; CHECK-32:       # %bb.0: # %entry
; CHECK-32-NEXT:    w4 = 1
; CHECK-32-NEXT:    r3 = w3
; CHECK-32-NEXT:    if r3 == 0 goto LBB1_2
; CHECK-32-NEXT:  # %bb.1: # %entry
; CHECK-32-NEXT:    w4 = 0
; CHECK-32-NEXT:  LBB1_2: # %entry
; CHECK-32-NEXT:    w4 &= 1
; CHECK-32-NEXT:    if r4 != 0 goto LBB1_5
; CHECK-32-NEXT:  # %bb.3: # %for.body.preheader
; CHECK-32-NEXT:    w1 = *(u16 *)(r1 + 0)
; CHECK-32-NEXT:  LBB1_4: # %for.body
; CHECK-32-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-32-NEXT:    w4 = w1
; CHECK-32-NEXT:    w4 &= 65535
; CHECK-32-NEXT:    *(u32 *)(r2 + 0) = w4
; CHECK-32-NEXT:    r2 += 4
; CHECK-32-NEXT:    w1 ^= -1
; CHECK-32-NEXT:    r3 += -1
; CHECK-32-NEXT:    if r3 == 0 goto LBB1_5
; CHECK-32-NEXT:    goto LBB1_4
; CHECK-32-NEXT:  LBB1_5: # %for.cond.cleanup
; CHECK-32-NEXT:    exit
entry:
  %cmp8 = icmp eq i32 %k, 0
  br i1 %cmp8, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %0 = load i16, i16* %a, align 2
  %wide.trip.count = zext i32 %k to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %e.09 = phi i16 [ %0, %for.body.preheader ], [ %neg, %for.body ]
  %conv = zext i16 %e.09 to i32
  %arrayidx = getelementptr inbounds i32, i32* %b, i64 %indvars.iv
  store i32 %conv, i32* %arrayidx, align 4
  %neg = xor i16 %e.09, -1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}
